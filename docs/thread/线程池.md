#  线程池

合理使用线程池的好处：

1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
2. 提高响应速度。当任务达到时，任务可以不需要等到线程创建就能立即执行。
3. 提高线程的可管理性。线程池可以进行统一分配、调优和监控系统资源。



# 实现原理

当向线程池提交一个任务之后，线程池是如何处理这个任务的呢？

1. 线程池判断核心线程池里的线程释放都在执行任务。如果是，创建一个新的工作线程来执行任务。如果核心线程池里面的线程都在执行任务，则进入下个流程。
2. 线程池判断工作队列是否已满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。
3. 线程池判断线程池的线程释放处理工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。



![threadpool](image/threadpool-1.png ':size=50%')





# 源码分析

## ThreadPoolExecutor.execute()

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    
    int c = ctl.get();
    // 当前线程池中线程比核心数少，新建一个线程执行任务
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    // 核心池已满，但任务队列未满，则添加到队列
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        //任务成功添加到队列以后，再次检查是否需要添加新的线程，因为已存在的线程可能被销毁了
        if (!isRunning(recheck) && remove(command)) 
            //如果线程池处于非运行状态，并且把当前的任务从任务队列中移除成功，则拒绝该任务
            reject(command);
        else if (workerCountOf(recheck) == 0) // 如果之前的线程已销毁，新建一个线程
            addWorker(null, false);
    }
    else if (!addWorker(command, false)) // 核心线程池已满，队列已满，尝试新建一个线程
        reject(command); // 创建线程失败，执行拒绝策略
}
```



## ThreadPoolExecutor.addWorker()

```java
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        
		//如果线程处于非运行状态，并且 rs 不等于 SHUTDOWN 且 firstTask 不等于空且且 workQueue 为空，直接返回 false(表示不可添加 work 状态)
		//1. 线程池已经 shutdown 后，还要添加新的任务，拒绝
		//2. (第二个判断)SHUTDOWN 状态不接受新任务，但仍然会执行已经加入任务队列的任 务，所以当进入 SHUTDOWN 状态，而传进来的任务为空，并且任务队列不为空的时候，是允许添加 新线程的,如果把这个条件取反，就表示不允许添加 worker
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            return false;

        for (;;) {
            //获得Worker工作线程数
            int wc = workerCountOf(c);
            //如果工作线程数大于默认容量大小或者大于核心线程数大小，则直接返回 false 表示不 能再添加 worker。
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            if (compareAndIncrementWorkerCount(c)) //通过cas来增加工作线程数， 如果 cas 失败，则直接重试
                break retry;
            c = ctl.get();  // Re-read ctl
            if (runStateOf(c) != rs) //这里如果不想等，说明线程的状态发生了变化,继续重试
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }
	//上面这段代码主要是对 worker 数量做原子+1 操作,下面的逻辑才是正式构建一个 worker
    boolean workerStarted = false; //工作线程是否启动的标识
    boolean workerAdded = false; //工作线程是否已经添加成功的标识
    Worker w = null;
    try {
        w = new Worker(firstTask); //构建一个Worker，这个worker是什么呢?我们 可以看到构造方法里面传入了一个 Runnable 对象
        final Thread t = w.thread; //从 worker 对象中取出线程
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock(); //这里有个重入锁，避免并发问题
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());
    			//只有当前线程池是正在运行状态，[或是 SHUTDOWN 且 firstTask 为空]，才能添加到 workers 集合中
                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    //任务刚封装到 work 里面，还没 start,你封装的线程就是 alive，几个意思?肯定是要抛异常出去的
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    //将新创建的Worker添加到workers集合中
                    workers.add(w);
                    int s = workers.size();
                    //如果集合中的工作线程数大于最大线程数，这个最大线程数表示线程池曾经出现过的最大线程数
                    if (s > largestPoolSize)
                        //更新线程池出现过的最大线程数
                        largestPoolSize = s;
                    //表示工作线程创建成功了
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) { //如果worker添加成功
                t.start(); //启动线程
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w); //如果添加失败，就需要做一件事，就是递减实际工作线程数(还记得我们最开始的时候增加了工作线程数吗)
    }
    return workerStarted; //返回结果
}
```







// TODO 未写完





