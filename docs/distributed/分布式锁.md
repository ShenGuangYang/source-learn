# 分布式锁

目前主要有三种分布锁的实现方案

- 数据库锁
- Redis
- Zookeeper

使用分布式锁主要有三个考量点：

- 是否互斥（只有一个实例能获取到锁）
- 不能死锁
- 容错

# 数据库锁

## 悲观锁

利用 `select * from tableName where name='my-lock' for update` 。

这种方案可能出现锁表

## 乐观锁

利用 `update tableName set version = version + 1 where name = 'my-lock' and version = 0`

是基于 CAS 思想，不具有互斥性，不会产生锁等待而消耗资源，只有 update version 失败之后才能知道。



# Redis

## 简单方案

```bash
set my-lock 事务id nx px 5000
```

通过 redis 保证 key 的原子性这一特性来实现分布式锁服务。

如果 key 不存在，设置 key ，如果可以存在，返回失败。

- 设置过期时间是为了不会出现死锁情况。

- 设置事务 id 是保证在过期时间内，事务还没有执行完，锁提前被自动释放，其他线程拿到锁，而此时前一个事务执行释放锁操作导致的问题。在释放锁的时候比较事务id 来判断是否释放

这种方案看起来很完美，但是只适用于单机服务，在 redis 集群服务下，数据的同步是异步执行的，master 节点写入key 成功，但此时各个集群节点还未进行数据同步情况下，master节点宕机，slave 节点升级成master ，这时候其他实例还是可以获取到锁。

## redlock

RedLock的核心思想就是，同时使用多个Redis Master来冗余，且这些节点都是完全的独立的，也不需要对这些节点之间的数据进行同步。

假设我们有N个Redis节点，N应该是一个大于2的奇数。RedLock的实现步骤:

1. 取得当前时间
2. 使用上文提到的方法依次获取N个节点的Redis锁。
3. 如果获取到的锁的数量大于 （N/2+1）个,且获取的时间小于锁的有效时间(lock validity time)就认为获取到了一个有效的锁。锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。
4. 如果获取锁的数量小于 （N/2+1），或者在锁的有效时间(lock validity time)内没有获取到足够的说，就认为获取锁失败。这个时候需要向所有节点发送释放锁的消息。

对于释放锁的实现就很简单了。想所有的Redis节点发起释放的操作，无论之前是否获取锁成功。

这种方案的可靠性还待验证，而且这种方案严重依赖时间，时间发生错误就会出现问题。



# Zookeeper

## 通过临时顺序节点特性来实现

zookeeper的临时顺序节点拥有临时节点的特性，同时，在一个父节点下创建创建的子临时顺序节点，会根据节点创建的先后顺序，用一个32位的数字作为后缀，我们可以用key创建一个根节点，然后每次申请锁的时候在其下创建顺序节点，接着获取根节点下所有的顺序节点并排序，获取顺序最小的节点，如果该节点的名称与当前添加的名称相同，则表示能够获取锁，否则监听根节点下面的处于当前节点之前的节点的删除事件，如果监听生效，则回到上一步重新判断顺序，直到获取锁。



# 总结

数据库方案，因为数据库有性能瓶颈，所以不选用该方案。

所以对比 redis 与 zookeeper 方案

- 性能
  - redis 基于内存存储，每一次的获取锁操作直接判断是否存在即可。
  - zookeeper 基于磁盘存储，每一次获取锁操作都会去创建临时顺序节点，并在集群中同步数据之后才返回结果。相对来说性能比 redis 差。
- 可靠性
  - 锁的有效期：redis 通过过期时间判断可能会出现延迟，而zookeeper 的临时节点天然支持。
  - 集群容错：redis的 redLock方案可靠性待验证，而zookeeper 天然支持集群。
- 使用层面
  - 首次竞争锁：redis 必须要轮循尝试获取锁，zookeeper 会创建节点监听之后等待通知，zookeeper 优于 redis
  - 释放锁之后大量请求竞争锁：redis 锁一释放，会有大量请求是竞争锁（惊群效应）可能会导致服务出现问题，而zookeeper 则是通过节点顺序，依次通知。



从上面的方案对比，redis 除了性能层面比zookeeper 好，其他都不如zookeeper。

