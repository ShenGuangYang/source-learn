# 分布式事务
现在只要有分布式系统，那么必定会用到分布式事务。
分布式事务的实现主要有以下 6 种方案：
- XA 方案(二阶段提交方案)
- TCC 方案
- Saga 方案
- 本地消息表
- 可靠消息最终一致性方案
- 最大努力通知方案


## XA 方案(二阶段提交方案)

XA 方案(二阶段提交方案)，有一个**事务管理器(Transaction Manager)**的概念，负责协调多个数据库(**资源管理器 Resource Manager**)的事务，事务管理器先询问各个数据库是否准备成功，如果成功就提交事务，如果失败就回滚事务。

这种方案在分布式系统内基本上是不用的，因为在一个系统中操作不属于自己系统内的数据库是不合规的。

## TCC 方案

TCC 的全程是 Tty、Confirm、Cancel。

- Try：对各个服务的资源做检测、锁定
- Confirm：执行实际的操作，成功就提交事务
- cancel：如果有一个服务方法出错，需要进行补偿，回滚逻辑



这种方案的事务回滚需要自己手写逻辑来回滚操作。在支付交易相关场景用的比较多，不过还是比较心累。

## Saga 方案

金融核心业务可能会选择 TCC 方案，以追求强一致性和更高的并发量，而其他业务往往会选择补偿事务。目前使用比较多的就是 Saga 作为长事务的解决方案。

**原理**

业务流程中每个参与者都提交本地事务，若其中一个参与者失败，则补偿前面已经成功的参与者。

就拿下单业务来说，正常会进行锁定库存、锁定优惠券、锁定红包、创建订单流程，当创建订单发送了错误，则开始反向执行补偿事务解锁红包、解锁优惠券、解锁库存，把原来已执行的数据补偿掉。

![](image/tx-1.png ':size=20%')



**使用场景**

对于一致性要求高、流程短、并发高的场景，如金融、支付核心业务，会优先考虑 TCC 方案。比如其他业务场景则只需要保证最终一致性即可。

**优势**

- 提交本地事务，无锁，性能高
- 参与者可以异步执行
- 补偿服务容易实现，反向更新操作是比较简单的

**缺点**

- 不能保证事务隔离性

## 本地消息表

核心思想是将分布式事务拆分成本地事务进行处理。

大概处理流程如下：

1. A 系统在本地事务操作的同时，插入一条消息到数据表（同一个数据库实现消息、业务的事务）
2. A 系统将这个消息发送到 MQ 中；
3. B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条消息，同时执行其他业务操作，如果这个消息被处理了，那么事务回滚，保证消息不会被重复消费；
4. B 系统执行成功之后，就会更新自己本地消息表的状态以及A系统消息表的状态；
5. 如果 B 系统处理是失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到MQ 中，让B再次处理；
6. 这个方案保证了最终一致性，A 会一直重发消息，直到 B 处理成功。



**优势**

- 避免了分布式事务，实现了最终一致性。

**缺点**

- 消息表会耦合到业务系统
- 高并发场景下，消息表是写入到数据库，存在性能瓶颈
- 扩展麻烦



## 可靠消息最终一致性方案

这个是基于本地消息表方案的优化，本地消息不适用数据库来实现事务，而是使用 MQ 来实现。比如使用阿里的 RocketMQ 来实现消息事务。

大概处理流程如下：

1. A 系统先发送一个 prepared 消息到 MQ，如果这个消息发送失败就直接取消执行后续操作；
2. 如果发送成功，那就接着执行本地事务，如果成功就告诉 MQ 发送确认消息，如果失败就告诉 MQ 回滚消息；
3. 如果发送了确认消息，那么此时 B 系统会接受到确认消息，然后执行本地事务；
4. MQ 会定时自动轮循所有的 prepared 消息回调接口，判断这消息是不是本地处理失败了，针对所有没有发送确认的消息进行重试或回滚操作。（避免本地事务成功而确认消息发送失败）
5. 如果 B 系统的事务失败，可以设置重试次数，到一定次数可以进行业务回滚，也通知 A 系统回滚进行补偿业务。









