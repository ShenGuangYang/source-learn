# JMM

## 内存模型

JMM 定义了线程和主内存之间的抽象关系：

1. 线程之间的共享变量存储在主内存中
2. 每个线程都有一个私有的本地内存，本地内存存储了该线程以读/写共享变量的副本

?> 共享变量： 所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间共享。



![](image/JMM-1.png ':size=50%')

## 线程间的通信

如上图所示，如果线程A与线程B之间要通信的话，必须要经历下面2个步骤：

1. 线程A把本地内存A更新过的共享变量刷新到主内存中去。
2. 线程B到主内存中去读取线程A之前更新付的共享变量。

> 从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要 经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供 内存可见性保证。

## 指令重排序

在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分为3重类型。

1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
2. 指令级并行的重排序。处理器采用指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3. 内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

JMM 针对不同的重排序的处理：

1. 对于编译器(1)，JMM的编译器重排序规则会禁止特定类型的编译器重排序。
2. 对于处理器(2、3)，JMM的处理器重排序规则会要求Java编译器在生成指令时，插入特定类型的内存屏障，通过内存屏障来禁止特定类型的处理器重排序。

## 顺序一致性

### 顺序一致性内存模型

顺序一致性内存模型有两大特效：

1. 一个县城中的所有操作必须按照程序的顺序来执行。
2. （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子且立刻对所有线程可见。

模型如下图所示：

![](image/JMM-3.png ':size=50%')

在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个移动的开关可以连接到任意一个线程，同时每一个线程必须按照程序的顺序来执行内存读写操作。从上图可以看出，在任意时间点最多只能一个县城可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读写操作串行化。

### JMM 与顺序一致性模型对比

未进行同步的程序，JMM不保证其的有序性。比如，在当前线程把写过的数据缓存在本地内存中，在没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。这种情况下，当前线程跟其他线程看到的执行顺序是不一致的。

代码示例

```java
public class SynchronizedExample {
    int a = 0;
    boolean flag = false;
    public synchronized void writer() { // 获得锁
        a = 1;
        flag = true;
    }                                   // 释放锁
    public synchronized void reader() { // 获得锁
        if (flag) {
            int i = a;
        }
    }                                   // 释放锁
}
```



上述示例程序在JMM与顺序一致性模型中的对比：

![](image/JMM-2.png ':size=50%')

从这里我们可以看到，JMM 在具体是线上的基本方针为：在不改变（正确同步的）程序执行结果的前提下，尽可能地为编译器和处理器的优化大开方便之门。

## happens-before

在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里所说的两个操作可以是同一线程，也可以是不同线程。

happens-before 规则如下：

- 程序次序规则：一个线程内，代码书写顺序前面的操作先行后面的操作。
- 监视器规则：对一个锁的解锁，优先于随后对这个锁的加锁。
- volatile 规则：对于一个变量的写操作优先于后面对这个变量的读操作。
- 传递规则：如果操作A优先于操作B，操作B优先于操作C，那么操作A比对优先于操作C。
- 线程启动规则：如果线程A执行操作ThreadB.start()(启动线程B)，那么A线程的ThreadB.start()操作优先于线程B中的任意操作。
- 线程结束规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作优先于线程A从ThreadB.join()操作成功返回。

























